// ---FILE: tools/validate.js
// #!/usr/bin/env node
/**
 * MyFi Forge v1 — Validator + Snapshot Updater
 * - node tools/validate.js        => validate only (fails non-zero on errors)
 * - node tools/validate.js --fix  => validate + regenerate snapshots
 */
import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const MANIFEST_PATH = path.join(ROOT, "src/registry/manifest.json");

function readJson(p){
  return JSON.parse(fs.readFileSync(p, "utf8"));
}
function writeJson(p, obj){
  fs.mkdirSync(path.dirname(p), { recursive:true });
  fs.writeFileSync(p, JSON.stringify(obj, null, 2) + "\n", "utf8");
}
function exists(p){
  return fs.existsSync(p);
}
function relToRoot(p){
  return p.replace(ROOT + path.sep, "").replaceAll("\\","/");
}
function err(msg){
  console.error("✗ " + msg);
}
function ok(msg){
  console.log("✓ " + msg);
}

function validateManifestShape(man){
  const requiredTop = ["app","parts","surfaces","journeys","snapshots"];
  const missing = requiredTop.filter(k => !(k in man));
  if(missing.length) return `Manifest missing keys: ${missing.join(", ")}`;
  if(typeof man.parts !== "object" || !man.parts) return "manifest.parts must be an object";
  if(typeof man.surfaces !== "object" || !man.surfaces) return "manifest.surfaces must be an object";
  if(typeof man.journeys !== "object" || !man.journeys) return "manifest.journeys must be an object";
  return null;
}

function checkFileRef(from, ref){
  // ref is like "./src/parts/X/part.js"
  const abs = path.join(ROOT, ref);
  if(!exists(abs)){
    return `Missing file referenced by ${from}: ${ref}`;
  }
  return null;
}

function extractRequiredHooksFromContract(contract){
  const req = contract?.hooks?.required;
  return Array.isArray(req) ? req : [];
}

function findHooksInBaselineHtml(html){
  const hooks = new Set();
  const rx = /data-hook\s*=\s*"([^"]+)"/g;
  let m;
  while((m = rx.exec(html))) hooks.add(m[1]);
  return hooks;
}

function readText(p){
  return fs.readFileSync(p, "utf8");
}

function run({ fix=false }){
  let errors = 0;

  if(!exists(MANIFEST_PATH)){
    err(`Missing manifest: ${relToRoot(MANIFEST_PATH)}`);
    process.exit(1);
  }

  const man = readJson(MANIFEST_PATH);

  const shapeErr = validateManifestShape(man);
  if(shapeErr){
    err(shapeErr);
    process.exit(1);
  }
  ok("Manifest shape OK");

  // Check referenced files exist
  for(const [partId, p] of Object.entries(man.parts)){
    const base = `manifest.parts["${partId}"]`;

    for(const k of ["module","contract","baseline"]){
      const e = checkFileRef(`${base}.${k}`, p[k]);
      if(e){ err(e); errors++; }
    }
    if(p.upliftCss){
      const e = checkFileRef(`${base}.upliftCss`, p.upliftCss);
      if(e){ err(e); errors++; }
    }

    // Contract required hooks exist in baseline.html
    try{
      const contractAbs = path.join(ROOT, p.contract);
      const baselineAbs = path.join(ROOT, p.baseline);
      const contract = readJson(contractAbs);
      const html = readText(baselineAbs);
      const requiredHooks = extractRequiredHooksFromContract(contract);
      const present = findHooksInBaselineHtml(html);
      for(const hk of requiredHooks){
        if(!present.has(hk)){
          err(`Part "${partId}" baseline missing required hook "${hk}"`);
          errors++;
        }
      }
    } catch(e){
      err(`Failed reading contract/baseline for part "${partId}": ${e.message}`);
      errors++;
    }
  }
  ok("Parts file refs + required hooks checked");

  for(const [surfaceId, s] of Object.entries(man.surfaces)){
    const e = checkFileRef(`manifest.surfaces["${surfaceId}"].url`, s.url);
    if(e){ err(e); errors++; }
  }
  ok("Surfaces file refs checked");

  for(const [journeyId, j] of Object.entries(man.journeys)){
    const e = checkFileRef(`manifest.journeys["${journeyId}"].url`, j.url);
    if(e){ err(e); errors++; }
  }
  ok("Journeys file refs checked");

  // Snapshot generation
  const pathsSnapRef = man.snapshots?.paths;
  const expectedManRef = man.snapshots?.expectedManifest;

  if(!pathsSnapRef || !expectedManRef){
    err("manifest.snapshots must include paths and expectedManifest");
    errors++;
  } else if(fix){
    const now = new Date().toISOString();
    const pathsSnapAbs = path.join(ROOT, pathsSnapRef);
    const expectedAbs = path.join(ROOT, expectedManRef);

    writeJson(pathsSnapAbs, {
      generatedAt: now,
      parts: Object.keys(man.parts),
      surfaces: Object.keys(man.surfaces),
      journeys: Object.keys(man.journeys)
    });

    writeJson(expectedAbs, {
      note: "This snapshot is regenerated by tools/validate.js --fix. Keep it committed to detect drift.",
      expectedKeys: ["app","parts","surfaces","journeys","snapshots"]
    });

    ok("Snapshots regenerated (--fix)");
  } else {
    ok("Snapshots not regenerated (run with --fix to update)");
  }

  if(errors){
    err(`${errors} validation error(s).`);
    process.exit(1);
  } else {
    ok("Validation passed.");
  }
}

const fix = process.argv.includes("--fix");
run({ fix });
