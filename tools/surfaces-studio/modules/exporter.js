// tools/surfaces-studio/modules/exporter.js
import { $, $$ } from './dom.js';
import { toast } from './toast.js';

export function initExporter(state) {
  const pop = $('#exportPopover');
  const menuBtn = $('#btnExportMenu');
  const exportBtn = $('#btnExport');

  // Copy buttons are emitted by slotDesigner
  state.on('copyJson', async () => { await copyText(buildJSON(state)); toast('Copied JSON'); });
  state.on('copyHtml', async () => { await copyText(buildHTML(state)); toast('Copied HTML'); });
  state.on('copyCss', async () => { await copyText(buildCSS(state)); toast('Copied CSS'); });

  $('#btnCopyJson')?.addEventListener('click', async () => { await copyText(buildJSON(state)); toast('Copied JSON'); });
  $('#btnCopyHtml')?.addEventListener('click', async () => { await copyText(buildHTML(state)); toast('Copied HTML'); });
  $('#btnCopyCss')?.addEventListener('click', async () => { await copyText(buildCSS(state)); toast('Copied CSS'); });

  function showPop() {
    if (!pop) return;
    pop.hidden = false;
    const r = menuBtn.getBoundingClientRect();
    pop.style.top = `${Math.max(60, r.bottom + 8)}px`;
    pop.style.right = `18px`;
  }
  function hidePop() {
    if (!pop) return;
    pop.hidden = true;
  }

  menuBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    if (pop?.hidden) showPop(); else hidePop();
  });
  window.addEventListener('click', hidePop);

  pop?.addEventListener('click', async (e) => {
    const btn = e.target?.closest?.('[data-export]');
    const type = btn?.dataset?.export;
    if (!type) return;
    hidePop();

    if (type === 'all') {
      await copyText([
        '/* --- HTML --- */\n' + buildHTML(state),
        '\n\n/* --- CSS --- */\n' + buildCSS(state),
        '\n\n/* --- JSON --- */\n' + buildJSON(state),
        '\n\n/* --- ui.parts.js --- */\n' + buildPartsJS(state)
      ].join('\n'));
      toast('Copied all');
      return;
    }

    if (type === 'html') { await copyText(buildHTML(state)); toast('Copied HTML'); return; }
    if (type === 'css')  { await copyText(buildCSS(state)); toast('Copied CSS'); return; }
    if (type === 'json') { await copyText(buildJSON(state)); toast('Copied JSON'); return; }
    if (type === 'parts'){ await copyText(buildPartsJS(state)); toast('Copied ui.parts.js'); return; }
  });

  exportBtn?.addEventListener('click', async () => {
    await copyText(buildJSON(state));
    toast('Copied JSON');
  });
}

function buildJSON(state) {
  const obj = {
    version: 2,
    surface: { type: state.surfaceType, id: state.surfaceId },
    canvas: { w: state.canvasW, h: state.canvasH, cols: state.gridCols, rows: state.gridRows },
    slots: state.rootSlots,
    partsMap: state.partsMap,
    partsLibrary: state.partsLibrary // âœ… include inventory
  };
  return JSON.stringify(obj, null, 2);
}

function buildHTML(state) {
  // Slots-only scaffold HTML (layout output)
  const slots = flattenSlots(state.rootSlots);
  const lines = [];
  lines.push(`<!-- surface: ${state.surfaceType}/${state.surfaceId} -->`);
  lines.push(`<div class="surface">`);
  for (const s of slots) {
    lines.push(`  <div id="${s.id}" class="slot ${s.variant ? `is-${s.variant}` : ''}"></div>`);
  }
  lines.push(`</div>`);
  return lines.join('\n');
}

function buildCSS(state) {
  const slots = flattenSlots(state.rootSlots);
  const lines = [];
  lines.push(`/* surface: ${state.surfaceType}/${state.surfaceId} */`);
  lines.push(`.surface{ position:relative; width:${state.canvasW}px; height:${state.canvasH}px; }`);
  for (const s of slots) {
    lines.push(`#${s.id}{ position:absolute; left:${s.x}px; top:${s.y}px; width:${s.w}px; height:${s.h}px; }`);
  }
  return lines.join('\n');
}

function buildPartsJS(state) {
  // A minimal registry export (slot->part mapping)
  const map = state.partsMap || {};
  const out = [];
  out.push(`// Generated by Surfaces Studio`);
  out.push(`export const partsMap = ${JSON.stringify(map, null, 2)};`);
  return out.join('\n');
}

function flattenSlots(root) {
  const out = [];
  (function walk(list) {
    for (const s of (list || [])) {
      out.push(s);
      if (s.children?.length) walk(s.children);
    }
  })(root);
  return out;
}

async function copyText(txt) {
  try {
    await navigator.clipboard.writeText(txt);
    return true;
  } catch {
    // fallback
    const ta = document.createElement('textarea');
    ta.value = txt;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    ta.remove();
    return true;
  }
}
